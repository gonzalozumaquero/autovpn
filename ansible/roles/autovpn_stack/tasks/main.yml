# roles/autovpn_stack/tasks/main.yml

- name: Asegurar directorio de despliegue
  ansible.builtin.file:
    path: "{{ deploy_dir }}"
    state: directory
    mode: "0755"

# ========= Validaciones de origen (en el CONTROLADOR) =========
- name: Comprobar existencia de stack/docker-compose.yml en el controlador
  ansible.builtin.stat:
    path: "{{ (stack_src_dir | default('/app/stack')) }}/docker-compose.yml"
  register: _dc_stat
  delegate_to: localhost
  run_once: true
  changed_when: false

- name: Fallar si falta docker-compose.yml en el controlador
  ansible.builtin.fail:
    msg: >-
      Falta el artefacto en el controlador:
      {{ (stack_src_dir | default('/app/stack')) }}/docker-compose.yml
  when: not _dc_stat.stat.exists
  delegate_to: localhost
  run_once: true

# ========= Copia de artefactos =========
- name: Copiar docker-compose.yml al servidor
  ansible.builtin.copy:
    src: "{{ (stack_src_dir | default('/app/stack')) }}/docker-compose.yml"
    dest: "{{ deploy_dir }}/docker-compose.yml"
    mode: "0644"

# (Opcional) build local del backend
- name: Verificar si existe backend para build local en el controlador
  ansible.builtin.stat:
    path: "{{ (stack_src_dir | default('/app/stack')) }}/backend/Dockerfile"
  register: _backend_build
  delegate_to: localhost
  run_once: true
  changed_when: false

- name: Copiar backend/ al servidor (build local)
  ansible.builtin.copy:
    src: "{{ (stack_src_dir | default('/app/stack')) }}/backend/"
    dest: "{{ deploy_dir }}/backend/"
    mode: "0644"
    directory_mode: "0755"
  when: _backend_build.stat.exists

# ========= Generación del .env (canónica) =========
- name: Renderizar .env desde backend.env.j2 (controlador → remoto)
  ansible.builtin.template:
    src: backend.env.j2           # plantilla del rol (roles/autovpn_stack/templates/backend.env.j2)
    dest: "{{ deploy_dir }}/.env"
    mode: "0640"
  no_log: true

# ========= Artefactos cifrados (Vault) opcionales =========
- name: Asegurar carpeta de artifacts en el controlador
  ansible.builtin.file:
    path: "artifacts"
    state: directory
    mode: "0750"
  delegate_to: localhost
  run_once: true

- name: Leer contenido del .env recién generado (desde el target)
  ansible.builtin.slurp:
    src: "{{ deploy_dir }}/.env"
  register: env_slurped
  no_log: true

- name: Aviso - no se cifrará .env (no hay vault_password)
  ansible.builtin.debug:
    msg: "Saltando cifrado Vault: variable 'vault_password' no definida."
  when: vault_password is not defined or (vault_password | length) == 0
  run_once: true
  delegate_to: localhost

- name: Preparar password file temporal para Vault (controlador)
  ansible.builtin.copy:
    dest: "/tmp/.vault_pw_{{ inventory_hostname }}"
    content: "{{ vault_password }}"
    mode: "0600"
  when: vault_password is defined and (vault_password | length) > 0
  run_once: true
  delegate_to: localhost
  no_log: true

- name: Escribir .env plano como archivo temporal en controlador
  ansible.builtin.copy:
    dest: "/tmp/.env_plain_{{ inventory_hostname }}"
    content: "{{ env_slurped.content | b64decode }}"
    mode: "0600"
  when: vault_password is defined and (vault_password | length) > 0
  run_once: true
  delegate_to: localhost
  no_log: true

- name: Cifrar .env con ansible-vault (a fichero)
  ansible.builtin.command:
    cmd: >-
      ansible-vault encrypt
      --vault-password-file /tmp/.vault_pw_{{ inventory_hostname }}
      --output artifacts/{{ inventory_hostname }}.autovpn.env.vault
      /tmp/.env_plain_{{ inventory_hostname }}
  when: vault_password is defined and (vault_password | length) > 0
  register: vault_encrypt
  changed_when: "'Encryption successful' in vault_encrypt.stdout"
  run_once: true
  delegate_to: localhost
  no_log: true

- name: Limpiar temporales de vault (controlador)
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  loop:
    - "/tmp/.vault_pw_{{ inventory_hostname }}"
    - "/tmp/.env_plain_{{ inventory_hostname }}"
  when: vault_password is defined and (vault_password | length) > 0
  run_once: true
  delegate_to: localhost
  no_log: true

# ========= Validación de Compose (previa al up) =========
- name: Validar docker compose config con .env
  ansible.builtin.command:
    cmd: docker compose --env-file .env config
    chdir: "{{ deploy_dir }}"
  environment:
    COMPOSE_PROFILES: "{{ (transport.mode == 'manual' and transport.profile == 'WG_UDP2RAW_443') | ternary('udp2raw','') }}"
  register: compose_cfg
  changed_when: false

# ========= Levantar el stack =========
- name: docker compose up -d
  ansible.builtin.command:
    cmd: docker compose up -d
    chdir: "{{ deploy_dir }}"
  environment:
    COMPOSE_PROFILES: "{{ (transport.mode == 'manual' and transport.profile == 'WG_UDP2RAW_443') | ternary('udp2raw','') }}"
  register: compose_up
  changed_when: "'Creating' in compose_up.stdout or 'Recreating' in compose_up.stdout"

- name: Mostrar salida de docker compose
  ansible.builtin.debug:
    var: compose_up.stdout

