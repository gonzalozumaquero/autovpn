- name: AutoVPN · Stack (reverse proxy + backend + frontend + WireGuard)
  hosts: cloud
  become: true
  gather_facts: yes

  vars_files:
    - group_vars/cloud.yml   # usa las variables generadas en la FASE 1

  pre_tasks:
    - name: Definir defaults para transport si no viene en group_vars
      ansible.builtin.set_fact:
        transport: >-
          {{
            {'mode': 'auto', 'profile': 'WG_UDP_51820', 'udp2raw': {'enabled': false}}
            | combine(transport | default({}), recursive=True)
          }}
    - name: Comprobar variables requeridas para el stack
      ansible.builtin.assert:
        that:
          - wg_public_host is defined and wg_public_host | length > 0
          - wg_port is defined
          - wg_subnet is defined and wg_subnet | length > 0
          - wg_dns is defined and wg_dns | length > 0
          - jwt_secret is defined and jwt_secret | length > 0
          - (use_internal_tls is defined) or (domain is defined)
          - admin_email is defined and admin_email | length > 3
          - admin_password is defined and admin_password | length >= 8
          - (transport.mode | default('auto')) in ['auto','manual']
          - ((transport.mode | default('auto')) == 'auto')
            or ((transport.profile | default('WG_UDP_51820')) in ['WG_UDP_51820','WG_UDP_443','WG_UDP2RAW_443'])          
        fail_msg: >-
          Faltan variables en group_vars/cloud.yml (wg_public_host, wg_port, wg_subnet,
          wg_dns, jwt_secret y/o use_internal_tls|domain).
        success_msg: "Variables mínimas OK."

    - name: Verificar que Docker está instalado
      ansible.builtin.command: docker --version
      changed_when: false

    - name: Verificar plugin docker compose
      ansible.builtin.command: docker compose version
      changed_when: false

    - name: Definir directorios por defecto
      ansible.builtin.set_fact:
        deploy_dir: "{{ deploy_dir | default('/opt/autovpn') }}"
        stack_src_dir: "{{ stack_src_dir | default('/app/stack') }}"

    - name: Comprobar que passlib esta operativo
      ansible.builtin.pip:
        name: passlib==1.7.4
        extra_args: --user
      delegate_to: localhost
      run_once: true

    - name: Validar parámetros admin (mínimos)
      ansible.builtin.assert:
        that:
          - admin_email is match("^[^@]+@[^@]+\\.[^@]+$")
          - (admin_password | length) >= 8
        fail_msg: "admin_email o admin_password inválidos"

    - name: Mostrar intérprete de Ansible en el controlador
      ansible.builtin.debug:
        msg: "ansible_playbook_python={{ ansible_playbook_python }}"
      delegate_to: localhost

    - name: Instalar passlib[bcrypt] (controlador)
      ansible.builtin.pip:
        name:
          - "passlib>=1.7.4"
          - "bcrypt>=4.0.1"
        extra_args: --user
      delegate_to: localhost

    - name: Verificar import passlib/bcrypt en el controlador
      ansible.builtin.command:
        cmd: "{{ ansible_playbook_python }} -c 'import passlib, bcrypt; print(passlib.__version__)'"
      delegate_to: localhost
      changed_when: false

    # === BLOQUE HASH ROBUSTO (bcrypt directo, sin passlib) ===
    - name: Derivar hash bcrypt (<=72 bytes reales) con bcrypt puro
      delegate_to: localhost
      ansible.builtin.command:
        cmd: >-
          {{ ansible_playbook_python }}
          -c
          "import os,sys,bcrypt;
          b=os.environ.get('PW','').encode('utf-8')[:72];
          sys.stdout.write(bcrypt.hashpw(b,bcrypt.gensalt(rounds=12)).decode())"
      environment:
        PW: "{{ admin_password | default('') }}"
        LC_ALL: C.UTF-8
        LANG: C.UTF-8
      register: _bcrypt
      changed_when: true
      failed_when: _bcrypt.rc != 0
    
    - name: Guardar hash derivado
      ansible.builtin.set_fact:
        admin_password_hash: "{{ _bcrypt.stdout | trim }}"
      no_log: true
    # === FIN BLOQUE HASH ROBUSTO ===

  roles:
    - role: reverse_proxy      # Caddy + Caddyfile(.internal) + volúmenes
    - role: autovpn_stack      # Copia stack/, genera .env e inicia docker compose
    - { role: backup, when: s3_bucket is defined and s3_bucket | length > 0 }

  post_tasks:
    - name: Wait for Caddy to bind :443 (TCP)
      ansible.builtin.wait_for:
        host: 127.0.0.1          # no uses ansible_host/IP pública aquí
        port: 443
        state: started
        delay: 2
        timeout: 120


    - name: Probe Caddy /health over HTTPS (SNI {{ wg_public_host }})
      ansible.builtin.uri:
        url: "https://{{ wg_public_host }}/health"
        method: GET
        return_content: true
        validate_certs: false
        status_code: 200
      register: caddy_health
      retries: 12
      delay: 5
      until: caddy_health.status == 200

    - name: Probe Caddy /health via loopback with SNI
      ansible.builtin.command:
        cmd: >
          curl -ksS --max-time 5
          --resolve "{{ wg_public_host }}:443:127.0.0.1"
          https://{{ wg_public_host }}/health
      register: curl_health
      retries: 12
      delay: 5
      until: curl_health.rc == 0
      changed_when: false


    - name: Mostrar estado de contenedores
      ansible.builtin.command: docker compose ps
      args:
        chdir: "{{ deploy_dir }}"
      register: compose_ps
      changed_when: false

    - name: Resumen del stack
      ansible.builtin.debug:
        msg:
          - "Stack desplegado en {{ deploy_dir }}."
          - "Servicios (docker compose ps):"
          - "{{ compose_ps.stdout_lines }}"
          - "URL esperada del panel: https://{{ wg_public_host }}/ (TLS {{ use_internal_tls | ternary('interno', 'ACME/dom') }})"
          - "WireGuard en {{ wg_public_host }}:{{ wg_port }}/udp (ver SG/UFW)."

