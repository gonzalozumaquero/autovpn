- name: AutoVPN · Stack (reverse proxy + backend + frontend + WireGuard)
  hosts: cloud
  become: true
  gather_facts: yes

  vars_files:
    - group_vars/cloud.yml   # usa las variables generadas en la FASE 1

  pre_tasks:
    - name: Definir defaults para transport si no viene en group_vars
      ansible.builtin.set_fact:
        transport: >-
          {{
            {'mode': 'auto', 'profile': 'WG_UDP_51820', 'udp2raw': {'enabled': false}}
            | combine(transport | default({}), recursive=True)
          }}
    - name: Comprobar variables requeridas para el stack
      ansible.builtin.assert:
        that:
          - wg_public_host is defined and wg_public_host | length > 0
          - wg_port is defined
          - wg_subnet is defined and wg_subnet | length > 0
          - wg_dns is defined and wg_dns | length > 0
          - jwt_secret is defined and jwt_secret | length > 0
          - (use_internal_tls is defined) or (domain is defined)
          - admin_email is defined and admin_email | length > 3
          - admin_password is defined and admin_password | length >= 8
          - (transport.mode | default('auto')) in ['auto','manual']
          - ((transport.mode | default('auto')) == 'auto')
            or ((transport.profile | default('WG_UDP_51820')) in ['WG_UDP_51820','WG_UDP_443','WG_UDP2RAW_443'])          
        fail_msg: >-
          Faltan variables en group_vars/cloud.yml (wg_public_host, wg_port, wg_subnet,
          wg_dns, jwt_secret y/o use_internal_tls|domain).
        success_msg: "Variables mínimas OK."

    - name: Verificar que Docker está instalado
      ansible.builtin.command: docker --version
      changed_when: false

    - name: Verificar plugin docker compose
      ansible.builtin.command: docker compose version
      changed_when: false

    - name: Definir directorios por defecto
      ansible.builtin.set_fact:
        deploy_dir: "{{ deploy_dir | default('/opt/autovpn') }}"
        stack_src_dir: "{{ stack_src_dir | default('/app/stack') }}"

    - name: Comprobar que passlib esta operativo
      ansible.builtin.pip:
        name: passlib==1.7.4
        extra_args: --user
      delegate_to: localhost
      run_once: true

    - name: Validar parámetros admin (mínimos)
      ansible.builtin.assert:
        that:
          - admin_email is match("^[^@]+@[^@]+\\.[^@]+$")
          - (admin_password | length) >= 8
        fail_msg: "admin_email o admin_password inválidos"

    - name: Mostrar intérprete de Ansible en el controlador
      ansible.builtin.debug:
        msg: "ansible_playbook_python={{ ansible_playbook_python }}"
      delegate_to: localhost

    - name: Instalar passlib[bcrypt] (controlador)
      ansible.builtin.pip:
        name:
          - "passlib>=1.7.4"
          - "bcrypt>=4.0.1"
        extra_args: --user
      delegate_to: localhost

    - name: Verificar import passlib/bcrypt en el controlador
      ansible.builtin.command:
        cmd: "{{ ansible_playbook_python }} -c 'import passlib, bcrypt; print(passlib.__version__)'"
      delegate_to: localhost
      changed_when: false

    # === BLOQUE HASH ROBUSTO (bcrypt directo, sin passlib) ===
    - name: Derivar hash bcrypt (<=72 bytes reales) con bcrypt puro
      delegate_to: localhost
      ansible.builtin.command:
        cmd: >-
          {{ ansible_playbook_python }}
          -c
          "import os,sys,bcrypt;
          b=os.environ.get('PW','').encode('utf-8')[:72];
          sys.stdout.write(bcrypt.hashpw(b,bcrypt.gensalt(rounds=12)).decode())"
      environment:
        PW: "{{ admin_password | default('') }}"
        LC_ALL: C.UTF-8
        LANG: C.UTF-8
      register: _bcrypt
      changed_when: true
      failed_when: _bcrypt.rc != 0
    
    - name: Guardar hash derivado
      ansible.builtin.set_fact:
        admin_password_hash: "{{ _bcrypt.stdout | trim }}"
      no_log: true
    # === FIN BLOQUE HASH ROBUSTO ===

  roles:
    - role: reverse_proxy      # Caddy + Caddyfile(.internal) + volúmenes
    - role: autovpn_stack      # Copia stack/, genera .env e inicia docker compose
    - role: autovpn_frontend 

  post_tasks:
    - name: Wait for Caddy to bind :443 (TCP)
      ansible.builtin.wait_for:
        host: 127.0.0.1
        port: 443
        state: started
        delay: 2
        timeout: 120

    - name: Detectar si wg_public_host es IPv4
      ansible.builtin.set_fact:
        _host_is_ipv4: "{{ (wg_public_host is match('^\\d+\\.\\d+\\.\\d+\\.\\d+$')) | bool }}"

    # ====== EXTERNO (ACME) ======
    - name: Probe Caddy /health over HTTPS (externo, FQDN con ACME)
      ansible.builtin.uri:
        url: "https://{{ wg_public_host }}/health"
        method: GET
        status_code: 200
        validate_certs: true
        return_content: false
        timeout: 5
      register: ext_health
      retries: 12
      delay: 2
      until: ext_health.status == 200
      changed_when: false
      when:
        - not (use_internal_tls | bool)
        - not _host_is_ipv4

    - name: Probe Caddy /health over HTTPS (externo, IP sin ACME)
      ansible.builtin.uri:
        url: "https://{{ wg_public_host }}/health"
        method: GET
        status_code: 200
        validate_certs: false
        return_content: false
        timeout: 5
      register: ext_ip_health
      retries: 12
      delay: 2
      until: ext_ip_health.status == 200
      changed_when: false
      when:
        - not (use_internal_tls | bool)
        - _host_is_ipv4

    # ====== INTERNO (TLS interno de Caddy) ======
    - name: Definir ruta a la CA interna de Caddy
      ansible.builtin.set_fact:
        caddy_ca: "{{ deploy_dir }}/caddy_data/caddy/pki/authorities/local/root.crt"

    # Caso 1: wg_public_host es FQDN → loopback + SNI correcto con --resolve
    - name: Probe Caddy /health (TLS interno, FQDN con loopback+SNI)
      ansible.builtin.command: >
        curl -ksS --fail --max-time 5
        --resolve "{{ wg_public_host }}:443:127.0.0.1"
        --cacert "{{ caddy_ca }}"
        https://{{ wg_public_host }}/health
      register: local_health_fqdn
      retries: 12
      delay: 2
      until: local_health_fqdn.rc == 0
      changed_when: false
      when:
        - use_internal_tls | bool
        - not _host_is_ipv4

    # Caso 2: wg_public_host es IP → usar sitio localhost (requiere bloque 'localhost' en Caddyfile.internal)
    - name: Probe Caddy /health (TLS interno, localhost IPv4)
      ansible.builtin.command: >
        curl -4 -ksS --fail --max-time 5
        --resolve "localhost:443:127.0.0.1"
        --cacert "{{ caddy_ca }}"
        https://localhost/health
      register: local_health_localhost
      retries: 12
      delay: 2
      until: local_health_localhost.rc == 0
      changed_when: false
      when:
        - use_internal_tls | bool
        - _host_is_ipv4

    - name: Mostrar estado de contenedores
      ansible.builtin.command: docker compose ps
      args:
        chdir: "{{ deploy_dir }}"
      register: compose_ps
      changed_when: false
      
    - name: Resumen del stack
      ansible.builtin.debug:
        msg:
          - "Stack desplegado en {{ deploy_dir }}."
          - "Servicios (docker compose ps):"
          - "{{ compose_ps.stdout_lines }}"
          - "URL esperada del panel: https://{{ wg_public_host }}/ (TLS {{ use_internal_tls | ternary('interno', 'ACME/dom') }})"
          - "WireGuard en {{ wg_public_host }}:{{ wg_port }}/udp (ver SG/UFW)."

