services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: autovpn-backend
    restart: unless-stopped
    env_file: .env
    environment:
      # Overrides seguros si faltan en .env
      APP_MODE: server
      WG_MODE: ${WG_MODE:-container}                 # container|host
      WG_CONTAINER_NAME: ${WG_CONTAINER_NAME:-wireguard}
      WG_PUBLIC_HOST: ${WG_PUBLIC_HOST}
      WG_PORT: ${WG_PORT}
      WG_SUBNET: ${WG_SUBNET}
      WG_DNS: ${WG_DNS}
      JWT_SECRET: ${JWT_SECRET}
      TOTP_ISSUER: ${TOTP_ISSUER:-AutoVPN}
      TZ: ${TZ}
    volumes:
      - ./data:/app/data
      # Solo si el backend necesita hablar con el daemon Docker local
      - /var/run/docker.sock:/var/run/docker.sock
    expose:
      - "8000"                                       # Caddy reverse_proxy -> backend:8000
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request,sys; sys.exit(0 if urllib.request.urlopen('http://localhost:8000/health', timeout=2).getcode()==200 else 1)"]
      interval: 5s
      timeout: 3s
      retries: 20
      start_period: 10s
    networks: [internal]

  caddy:
    image: caddy:2-alpine
    env_file: .env
    container_name: caddy
    restart: unless-stopped
    ports:
      - "80:80"                                       # HTTP (ACME)
      - "443:443"                                     # HTTPS pÃºblico
    volumes:
      - ./reverse-proxy/Caddyfile:/etc/caddy/Caddyfile:ro
      - ./caddy_data:/data
      - ./caddy_config:/config
      - ./frontend/dist:/srv/frontend/dist:ro
    depends_on:
      backend:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://127.0.0.1:2019/config >/dev/null 2>&1 || exit 1"]
      interval: 10s
      timeout: 3s
      retries: 15
      start_period: 10s
    networks: [internal, public]

  wireguard:
    image: lscr.io/linuxserver/wireguard:latest
    container_name: wireguard
    restart: unless-stopped
    cap_add: [NET_ADMIN, SYS_MODULE]
    sysctls:
      - net.ipv4.ip_forward=1
      - net.ipv4.conf.all.src_valid_mark=1
      - net.ipv6.conf.all.disable_ipv6=1
    env_file: .env
    environment:
      PUID: ${PUID:-1000}
      PGID: ${PGID:-1000}
      TZ: ${TZ}
      SERVERURL: ${WG_PUBLIC_HOST}
      SERVERPORT: ${WG_PORT}
      PEERS: "0"                                     # gestionas peers desde backend
      PEERDNS: ${WG_DNS}
      INTERNAL_SUBNET: ${WG_SUBNET}
    volumes:
      - ./wireguard:/config
      - /lib/modules:/lib/modules:ro
    ports:
      - "${WG_PORT}:${WG_PORT}/udp"
    networks: [public, internal]

  udp2raw:
    image: ghcr.io/wangyu-/udp2raw:latest
    network_mode: host
    restart: unless-stopped
    profiles: ["udp2raw"]                            # activar con COMPOSE_PROFILES=udp2raw
    depends_on:
      - wireguard
    environment:
      WG_PORT: ${WG_PORT}
      UDP2RAW_PASSWORD: ${UDP2RAW_PASSWORD:-}
      UDP2RAW_MTU: ${UDP2RAW_MTU:-}
    entrypoint: ["/bin/sh","-c"]
    command: |
      extra=""
      if [ -n "$UDP2RAW_PASSWORD" ]; then extra="$extra --password \"$UDP2RAW_PASSWORD\""; fi
      if [ -n "$UDP2RAW_MTU" ]; then extra="$extra --mtu \"$UDP2RAW_MTU\""; fi
      exec udp2raw -s -l0.0.0.0:443 -r127.0.0.1:$WG_PORT --auth-mode simple --cipher-mode xor --raw-mode faketcp $extra

networks:
  internal:
    driver: bridge
  public:
    driver: bridge

